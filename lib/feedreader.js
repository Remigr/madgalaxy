/*----------------------------------------------------
  Global Variables
 ---------------------------------------------------*/
var path         = require('path');
var feedparser   = require('feedparser');
var request      = require('request');
var config       = require('../config.json');
var mongoose     = require('mongoose');
var colors       = require('colors');
var mongoosastic = require('mongoosastic');
var natural = require('natural');
var RSS = require('rss');

require('./models/post.js');
var mongooseUrl = process.env.MONGOHQ_URL || 'mongodb://127.0.0.1/planet';
mongoose.connect(mongooseUrl);
var postSchema = mongoose.model('postModel');

var feed = new RSS({
  title: 'MadGalaxy',
  description: 'A blog aggregator made for the universe',
  feed_url: 'http://madgalaxy.com/feed',
  author: 'MadGlory'
});
/*----------------------------------------------------
  end - Global Variables
 ---------------------------------------------------*/

/*----------------------------------------------------
  Build Functions
 ---------------------------------------------------*/

/*
  Checks to see if the doc is in the database
 */
function findPost(post, callback){
  var testVal;
  postSchema.findOne({link: post.link}).exec(function (err, foobar){
    if(foobar) {
      process.stdout.write('Already found the article: ' + foobar.title);
      testVal = true;
      callback(testVal);
    }else{
      testVal = false;
      callback(testVal);
    }
  });
}

/*
  Saves the post if it is not already in the database
 */
function savePost(postToSave) {
  findPost(postToSave, function(testVar) {
    if (!testVar) {
      postToSave.save(function (err, product, numberAffected) {
        if (err) {
          console.log(err);
        } else {
          console.log(('Adding the post to DB: '.red + postToSave.title));
        }
      });
    }else{
      console.log(' - not adding'.yellow);
    }
  });
}

/**
 * Is given a title and description and tries to determing tags
 * @param  {string}   articleTitle       
 * @param  {string}   articleDescription 
 * @param  {Function} callback           err, results
 */
function taggingSystem(articleTitle, articleDescription, callback){
  var natural = require('natural');
  var TfIdf = natural.TfIdf;
  var tfidf = new TfIdf();
  var tags = [];
  //not necessarily a horrible thing, but make sure you have atleast two documents because if there is only one, it will cause problems
  tfidf.addDocument(articleDescription);
  tfidf.addDocument(articleTitle);

  if (tfidf.tfidf('node', 0) >= .69 || tfidf.tfidf('NodeJS', 0) >= .69 || tfidf.tfidf('Node', 0) >= .69){
    tags.push('node');
    //console.log('added a tag: node');
  }
  if (tfidf.tfidf('npm', 0) >= .69 || tfidf.tfidf('NPM', 0) >= .69){
    tags.push('npm');
    //console.log('added a tag: npm');
  }
  if (tfidf.tfidf('AngularJS', 0) >= .69 ){
    tags.push('AngularJS');
    //console.log('added a tag: AngularJS');
  }
  if (tfidf.tfidf('BackboneJS', 0) >= .69 || tfidf.tfidf('Backbone', 0) >= .69 || tfidf.tfidf('backbone', 0) >= .69 ) {
    tags.push('BackboneJS');
    //console.log('added a tag: BackboneJS');
  }
  if (tfidf.tfidf('Ember.js', 0) >= .69 || tfidf.tfidf('Ember', 0) >= .69){
    tags.push('Ember.js');
    //console.log('added a tag: Ember.js');
  }
  if (tfidf.tfidf('JQuery', 0) >= .69 ){
    tags.push('JQuery');
    //console.log('added a tag: JQuery');
  }
  if (tfidf.tfidf('Ruby', 0) >= .69 ){
    tags.push('Ruby');
    //console.log('added a tag: Ruby');
  }
  if (tfidf.tfidf('Rails', 0) >= .69 ){
    tags.push('Rails');
    //console.log('added a tag: Rails');
  }
  if (tfidf.tfidf('PHP', 0) >= .69 ){
    tags.push('PHP');
    //console.log('added a tag: PHP');
  }
  if (tfidf.tfidf('Laravel', 0) >= .69 ){
    tags.push('Laravel');
    //console.log('added a tag: Laravel');
  }
  if (tfidf.tfidf('git', 0) >= .69 || tfidf.tfidf('.git', 0) >= .69 || tfidf.tfidf('Git', 0) >= .69 || tfidf.tfidf('GIT', 0) >= .69){
    tags.push('git');
    //console.log('added a tag: git');
  }
  if (tfidf.tfidf('CSS', 0) >= .69 ){
    tags.push('CSS');
    //console.log('added a tag: CSS');
  }

  /**
   * If no pre-determined tags were found from the description, try auto-generating some from the title
   */
  if(tags.length != 0){
    //console.log((tags + '').yellow);
  }
  else{
    
    var titleTags = [];    
    var tagsForArticle = (tfidf.listTerms(1)); //this is referencing the title - notice the 1 instead of 0
    //put autogenerated tags in 
    for (var item in tagsForArticle){
      titleTags.push(tagsForArticle[item].term);
    }
    for (var tag in titleTags){
      if (titleTags[tag] == 'node'){
        tags.push('node');
      }
      if (titleTags[tag] == 'backbone'){
        tags.push('BackboneJS');
      }
      if (titleTags[tag] == 'angularjs' || titleTags[tag] == 'angular'){
        tags.push('AngularJS');
      }
      if (titleTags[tag] == 'ruby'){
        tags.push('Ruby');
      }
      if (titleTags[tag] == 'rails'){
        tags.push('Rails');
      }
      if (titleTags[tag] == 'jquery'){
        tags.push('JQuery');
      }
      if (titleTags[tag] == 'css'){
        tags.push('CSS');
      }
      if (titleTags[tag] == 'npm'){
        tags.push('npm');
      }
      if (titleTags[tag] == 'ember'){
        tags.push('Ember.js');
      }
    }
    if (tags.length !=0){
      console.log(('Couldnt find pre-defined tags for: ' + articleTitle).yellow + '. Instead, I will add: ' + tags);
    }
    else{
      console.log(('Still could not generate tags for: ' + articleTitle).red);
    }
  }


  //used null just to follow convention, but eventually add in err trace
  callback(null, tags);
}

/**
 * Checks to see if post has all required info, generates the tags, and then sends if off to be saved
 * @param  {multi-dimmensional array} post        the article
 * @param  {array} defaultTags tags that are associated with parent feed
 * @return {null}             
 */
function parsePost(post, defaultTags) {
  if (post && post.title != '' && post.title != 'No title' && post.title && post.description) {
    var tagsToSave;
    taggingSystem(post.title, post.description, function(err, tags){
      tagsToSave = tags;      
    });
    
    var postObject = new postSchema({
      title: post.title,
      isoTimestamp: post.pubdate,
      site: post.blog,
      displayDate: post.pubdate.toString('MM dd yyyy'),
      content: post.description,
      link: post.link,
      author: post.author,
      tags: tagsToSave
    });
    savePost(postObject);
  }else{
    console.log('Not enough info to add post to database - aka: blank title, blank content, etc.');
  }
}

/**
 * This is what gets the articles from the rss feeds
 * @param  {array}   defaultTags tags associated with feed - obtained from config.json file
 * @param  {object}   blog         
 * @param  {Function} callback    
 */
function build(defaultTags, blog, callback) {
  var counter = 1;
  var req = request(blog.feed);
  var parser = new feedparser();

  req.on('error', function(error) {
    // handle any request errors
    console.log(error);
  });
  req.on('response', function(res) {
    var stream = this;
    if (res.statusCode !== 200) {
      return this.emit('error', new Error('Bad status code'));
    }
    stream.pipe(parser);
  });
  parser.on('readable', function() {
    // This is where the action is!
    var stream = this;
    var post;
    while (post = stream.read()) {
      parsePost(post, defaultTags);
    }
    counter++;
  });
  parser.on('end', function() {
    counter--;
    if (counter === 0 && callback) {
      callback();
      callback = null;
    }
  });
  parser.on('error', function(err) {
    console.error('%s - build error (%s) - [%s]: %s', new Date(), blog.feed, err, err.code);
    if (callback) callback();
    callback = null;
  });
}

/*----------------------------------------------------
  end - Build Functions
 ---------------------------------------------------*/

/*----------------------------------------------------
  Functions run from route file
 ---------------------------------------------------*/

function run(callback) {
  mongoose
    .model('postModel')
    .find()
    .sort({'displayDate': 'desc'})
    .limit(10)
    .exec(function(err, posts) {
      callback(posts);
    });
}

function getArticlesWithPageNum(pageNum, callback){
  var perPage = 10;
  var page = pageNum > 0 ? pageNum : 0;
  if(pageNum === 'forward'){
    mongoose
    .model('postModel')
    .find()
    .sort({'displayDate': 'desc'})
    .limit(10)
    .exec(function(err, posts) {
      callback(posts);
    });
  }
  else{
    mongoose
      .model('postModel')
      .find()
      .sort({'displayDate': 'desc'})
      .limit(perPage)
      .skip(perPage * (page-1))
      .exec(function(err, posts) {
        callback(posts);
      });
  }
}

function getArticleById(id, callback){
  postSchema
    .findById(id, function (err, doc) {
      console.log('Found the article user was requesting');
      callback(doc);
    });
}

function getArticlesBySearchString(searchString, callback){
  postSchema.search({query: searchString}, function(err, results) {
    if (err) throw err;
    var resultsToCallback = [];
    var esResults = results.hits.hits;
    for (var resultObject in esResults){
      resultsToCallback.push(esResults[resultObject]._source);
    }
    callback(resultsToCallback);
  });
}

function getArticlesByTag(tag, callback) {
  mongoose
    .model('postModel')
    .find( { tags: {$in: [tag]} })
    .sort({'displayDate': 'desc'})
    .exec(function(err, posts) {
      if (err) throw err;
      callback(posts);
    });
}

/**
 * Builds rss feed depending on tags
 * @param  {array}   param    a list of tags
 * @param  {Function} callback [description]
 */
function getRSS(param, callback){
  if (param){
    
    mongoose
      .model('postModel')
      .find( { tags: {$in: param} })
      .sort({'displayDate': 'desc'})
      .limit(10)
      .exec(function(err, posts) {
        if (err) throw err;
        var feed = new RSS({
          title: 'MadGalaxy RSS feed (built with tag:' + param + ')',
          description: 'A blog aggregator made for the universe',
          feed_url: 'http://madgalaxy.com/feed',
          author: 'MadGlory'
        });
        for (var i = 0; i < posts.length; i++) {      
          feed.item({
            title:        posts[i].title,
            description:  posts[i].content,
            url:          posts[i].link,
            content:      posts[i].content,
            author:       posts[i].author,
            date:         posts[i].displayDate,
            pubdate:      posts[i].displayDate,
            tags:         posts[i].tags
          });
        }
        callback(feed.xml()); 
        console.log('RSS feed built with the tags: ' + param);
      });
  }else{
    mongoose
      .model('postModel')
      .find()
      .sort({'displayDate': 'desc'})
      .limit(10)
      .exec(function(err, posts) {
        if (err) throw err;
        var feed = new RSS({
          title: 'MadGalaxy',
          description: 'A blog aggregator made for the universe',
          feed_url: 'http://madgalaxy.com/feed',
          author: 'MadGlory'
        });
        for (var i = 0; i < posts.length; i++) {          
          feed.item({
            title:       posts[i].title,
            description: posts[i].content,
            url:         posts[i].link,
            content:     posts[i].content,
            author:      posts[i].author,
            date:        posts[i].displayDate,
            pubdate:     posts[i].displayDate,
            tags:        posts[i].tags
          });
        }
        callback(feed.xml());
        console.log('RSS feed built');
      });
  }  
}
/*----------------------------------------------------
  end - Functions called from route file
 ---------------------------------------------------*/


/*----------------------------------------------------
  Startup Functions and Variables
 ---------------------------------------------------*/
function setup(){
  for (var site in config){
    var defaultTags = config[site].tags;
    build(defaultTags, config[site], function() {});
  }
}
setup();
var minutes = 30;
var theInterval = minutes * 60 * 1000;
setInterval(function() {
  console.log("This is the periodic update");
  setup();
}, theInterval);
/*----------------------------------------------------
  end - Startup Functions and Variables
 ---------------------------------------------------*/



exports.run                       = run;
exports.getArticlesWithPageNum    = getArticlesWithPageNum;
exports.getArticleById            = getArticleById;
exports.getArticlesBySearchString = getArticlesBySearchString;
exports.getRSS                    = getRSS;
exports.getArticlesByTag          = getArticlesByTag;